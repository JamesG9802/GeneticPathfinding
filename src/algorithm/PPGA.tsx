import { PriorityQueue } from "../utils/PriorityQueue";
import { UndirectedWeightedGraph } from "./graph/UndirectedWeightedGraph";
import { ValueMap } from "../utils/ValueMap";
import { Chromosome, crossover_individuals, mutate_individual, random_individual } from "./gene/Chromosome";

/**
 * The algorithm is descrbed as (RTP-GA) in https://doi.org/10.1109/SBGAMES.2011.23 though 
 * some of the same authors describe the algorithm as PPGA in https://www.sbgames.org/sbgames2012/proceedings/papers/computacao/comp-full_09.pdf.
 * @param graph - the graph to search on
 * @param starting_node - the starting position of the search
 * @param goal_node - the target position of the search 
 * @param equals - the closure determining if two nodes are equivalent
 * @param heuristic - the distance heuristic 
 * @returns the nodes that make up the path, if any
 */
export function* PPGA<TNode>(
    graph: UndirectedWeightedGraph<TNode>, 
    starting_node: TNode, 
    goal_node: TNode, 
    equals: (a: TNode, b: TNode) => boolean,
    heuristic: (from: TNode, to: TNode) => number): IterableIterator<[ValueMap<TNode, TNode>, TNode]> 
{
    /**
     * The possible nodes that haven't been searched yet.
     */
    let possible_nodes: PriorityQueue<TNode, number> = new PriorityQueue(true, equals);
    
    /**
     * A key-value pair means that the key was reached from the value. 
     */
    let connection_from: ValueMap<TNode, TNode> = new ValueMap<TNode, TNode>(); 
    
    /**
     * The total cost to reach a node.
     */
    let node_costs: ValueMap<TNode, number> = new ValueMap<TNode, number>();


    let previous_node: TNode = starting_node;

    /**
     * The percentage of distance until the goal is reached.
     */
    let distance_metric: number = 1;

    /**
     * The percentage of times the genetic algorithm's proposed subpaths worked.
     */
    let success_metric: number = 1;
    let success: number = 0;
    let attempts: number = 0;


    /**
     * The individuals for the genetic algorithm.
     */
    let individuals: Chromosome[] = [];

    type IndividualFitness = {
        individual: Chromosome,
        heuristic_distance: number
    }

    let individual_fitnesses: PriorityQueue<IndividualFitness, number> = new PriorityQueue<IndividualFitness, number>(true);

    //  Start by adding the starting node to the possible nodes to search.
    possible_nodes.push({ element: starting_node, priority: 0} );
    connection_from.set(starting_node, starting_node);
    node_costs.set(starting_node, 0);

    while(!possible_nodes.is_empty()) {
        //  Step 1 - get the current node
        let node: TNode = possible_nodes.peek().element;
        
        //  If the goal has been found, the search can stop
        if(equals(node, goal_node)) {
            return [connection_from, goal_node];
        }

        let genetic_algorithm_failed: boolean = true;

        if(
            //  Step 2 - if the genetic algorithm is still working, run it instead
            (distance_metric > 0.5 || success_metric > 0.4) &&
            
            //  Step 3 - But if the current node to be explored is closer to the goal, don't bother to 
            //  run the genetic algorithm and just take it.
            node_costs.get(node)! > node_costs.get(previous_node)!
        ) {
            //  Step 6 - Generate 4 random individuals

            //  a. Generate [an] initial population of 4 individuals. pg 69
            for(let i = 0; i < 4; i++) {
                individuals.push(random_individual(4));
            }
            //  b. Generate the first offspring by a crossover rate of the 4 first individuals.
            //  The established rate was 50%.
            individuals.push(crossover_individuals(individuals[0], individuals[1]));
            individuals.push(crossover_individuals(individuals[1], individuals[2]));
            individuals.push(crossover_individuals(individuals[2], individuals[3]));
            individuals.push(crossover_individuals(individuals[3], individuals[0]));
            
            //  c. The second off-spring is generated by the mutation of the initial population.
            //  The established rate for this stage was 25%.
            individuals.push(mutate_individual(individuals[0]));
            individuals.push(mutate_individual(individuals[1]));
            individuals.push(mutate_individual(individuals[2]));
            individuals.push(mutate_individual(individuals[3]));

            //  Verify the individuals.
            for(let i = 0; i < individuals.length; i++) {
                if(graph.restrict_null(individuals[i]) || graph.restrict_adjacent(individuals[i], previous_node)) {
                    individuals.splice(i);
                    i--;
                    continue;
                }
            }
            
            //  d. Calculate the fitness of the individuals.
            individual_fitnesses.clear();
            for(let i = 0; i < individuals.length; i++) {
                let evaluation: [number, number, TNode] = graph.evaluate_path(individuals[i], previous_node, goal_node, heuristic);
                
                //  If the path of graph ends in a node that already exists, don't bother to keep it
                if(node_costs.has(evaluation[2])){
                    continue;
                }

                individual_fitnesses.push({
                    element: { individual: individuals[i], heuristic_distance: evaluation[1] },
                    priority: evaluation[0],
                });
            }

            //  Purge invalid paths
            while(!individual_fitnesses.is_empty()) {
                if(individual_fitnesses.peek().priority < 0) {
                    individual_fitnesses.pop();
                }
                else {
                    break;
                }
            }

            //  Step 7 - Check if there any alive individuals.

            attempts += 1;

            while(!individual_fitnesses.is_empty()) {

                //  Step 9 - Check if the path is better than what A* was going to do.
                let best_fitness: IndividualFitness = individual_fitnesses.pop().element;

                if(best_fitness.heuristic_distance <= heuristic(node, goal_node)) {
                    genetic_algorithm_failed = false;
                    
                    //  Step 10 - Execute the subpath
                    
                    //  Change the node to be evaluated to end of the subpath.
                    node = graph.execute_path(best_fitness.individual, previous_node, goal_node, 
                        heuristic, possible_nodes, node_costs, connection_from);
                    
                    //  Clear the individual list and add the best individual to the next generation
                    individuals = [best_fitness.individual];

                    //  Increase the number of successful genetic algorithm attempts.
                    success += 1;
                    break;
                }
            }
            success_metric = success / attempts;
        }

        //  Step 4 - Take the A* recommended move.
        if (genetic_algorithm_failed) {
            node = possible_nodes.pop().element;
        }

        //  Step 5 - stop condition
        //  If the goal has been found, the search can stop
        if(equals(node, goal_node)) {
            return [connection_from, goal_node];
        }

        //  Then explore the chosen move (either from A* or the Genetic Algorithm)'s neighbors.

        previous_node = node;

        let neighbors: TNode[] = graph.neighbors(node);
        for(let i = 0; i < neighbors.length; i++) {
            let neighbor: TNode = neighbors[i];
            let new_cost: number = node_costs.get(node)! + graph.cost(node, neighbor);

            if(!node_costs.has(neighbor) || new_cost < node_costs.get(neighbor)!) {
                node_costs.set(neighbor, new_cost);
                
                //  A*
                // let priority: number = new_cost + heuristic(neighbor, goal_node);
                // BFS
                let priority: number = heuristic(neighbor, goal_node);
                
                possible_nodes.push({element: neighbor, priority: priority});
                connection_from.set(neighbor, node);
            }
        }

        //  Update the metrics
        if(distance_metric > 0.5 || success_metric > 0.4) {
            let distance_travelled = heuristic(starting_node, goal_node);
            let distance_remaining = heuristic(node, goal_node) + Number.EPSILON;
            distance_metric = distance_travelled / distance_remaining;
        }

        yield [connection_from, node];
    }

    return [connection_from, {x: -1, y: -1}];
}

export function rebuild_path<TNode>(
    connection_from: ValueMap<TNode, TNode>, 
    start_node: TNode,
    goal_node: TNode,
    node_equals: (a: TNode, b: TNode) => boolean
) 
{
    let node: TNode = goal_node;
    let path: TNode[] = [];

    //  Never reached the goal.
    if(!connection_from.has(goal_node)) {
        return path;
    }

    while(!node_equals(node, start_node)) {
        path.push(node);
        node = connection_from.get(node)!;
    }
    path.push(start_node);
    path.reverse();
    return path;
}

export { UndirectedWeightedGraph };
